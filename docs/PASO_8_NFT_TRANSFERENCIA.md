# Paso 8: Funcionalidad NFT - Transferencia de Certificados

## üìã Resumen Ejecutivo

Este documento describe la implementaci√≥n de la funcionalidad NFT (Token No Fungible) en el contrato `CarbonCertifier`, habilitando la transferencia de propiedad de certificados de carbono entre direcciones. Los certificados ahora pueden ser transferidos de forma segura con autorizaci√≥n y rastreabilidad completa.

**Fecha:** 29 de Octubre, 2025  
**Estado:** ‚úÖ Completado y probado  
**Tests Totales:** 32/32 pasando (6 nuevos tests NFT)  
**Contrato:** `contracts/carbon-certifier/`

---

## üéØ Objetivo

Implementar funcionalidad NFT completa para certificados de carbono:
1. **Propiedad On-Chain**: Rastrear el propietario de cada certificado
2. **Transferencia Segura**: Permitir transferencias entre direcciones con autorizaci√≥n
3. **Trazabilidad**: Eventos inmutables para auditor√≠a de transferencias
4. **Seguridad**: Prevenir robos con verificaci√≥n de propiedad y autenticaci√≥n

---

## üîß Cambios Implementados

### 1. Nuevo Error: `NotOwner`

**Archivo:** `contracts/carbon-certifier/src/contract.rs`

```rust
/// Errores del contrato
#[contracterror]
#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum ContractError {
    /// El certificado ya existe en el almacenamiento
    AlreadyExists = 1,
    /// El certificado no se encontr√≥ en el almacenamiento
    NotFound = 2,
    /// Datos de entrada inv√°lidos (hectares o CO2e <= 0)
    InvalidInput = 3,
    /// El llamador no es el propietario del certificado
    NotOwner = 4,  // ‚Üê NUEVO
}
```

**Uso:**
- Detecta intentos de transferir sin ser propietario
- Mensaje de error claro para debugging
- Prevenci√≥n de robos de certificados

### 2. Nuevo Evento: `CertificateTransferredEvent`

```rust
/// Evento de transferencia de certificado NFT
#[contractevent]
#[derive(Clone)]
pub struct CertificateTransferredEvent {
    /// ID √∫nico del certificado transferido
    pub certificate_id: u32,
    /// Direcci√≥n del propietario anterior
    pub from: Address,
    /// Direcci√≥n del nuevo propietario
    pub to: Address,
}
```

**Caracter√≠sticas:**
- Captura todos los datos de la transferencia
- Permite ingesta off-chain
- Inmutable en el ledger
- Auditor√≠a completa

### 3. Nueva DataKey: `CertificateOwner`

```rust
/// Claves para el almacenamiento
#[contracttype]
#[derive(Clone)]
pub enum DataKey {
    /// Almacenamiento persistente de certificados por ID (u32)
    Certificates(u32),
    /// Contador total de certificados en Instance Storage
    TotalCertificates,
    /// Contador total de CO2e acu√±ado en Instance Storage
    TotalCO2e,
    /// √çndice de certificados por agricultor (Persistent Storage)
    FarmerCertList(Address),
    /// √çndice de certificados por verificador (Persistent Storage)
    VerifierCertList(Address),
    /// Propietario actual de cada certificado NFT (Persistent Storage)  ‚Üê NUEVO
    CertificateOwner(u32),
}
```

**Almacenamiento:**
- Persistent Storage para longevidad
- Mapea `certificate_id` ‚Üí `Address`
- Actualizable solo por `transfer_certificate`

### 4. Funci√≥n: `get_certificate_owner()`

```rust
/// Obtiene el propietario actual de un certificado NFT
/// 
/// # Argumentos
/// * `env` - El entorno del contrato
/// * `certificate_id` - ID √∫nico del certificado (u32)
/// 
/// # Retorna
/// `Address` - La direcci√≥n del propietario actual
/// 
/// # Errores
/// * `ContractError::NotFound` si el certificado no existe
pub fn get_certificate_owner(
    env: Env,
    certificate_id: u32,
) -> Result<Address, ContractError> {
    // Verificar que el certificado existe
    let cert_key = DataKey::Certificates(certificate_id);
    if env.storage().persistent().get::<DataKey, VerificationRecord>(&cert_key).is_none() {
        return Err(ContractError::NotFound);
    }
    
    // Obtener el propietario
    let owner_key = DataKey::CertificateOwner(certificate_id);
    match env.storage().persistent().get(&owner_key) {
        Some(owner) => Ok(owner),
        None => Err(ContractError::NotFound),
    }
}
```

**L√≥gica:**
1. Verifica que el certificado existe
2. Busca el propietario en Persistent Storage
3. Retorna la Address del propietario
4. Error si no encuentra

### 5. Funci√≥n: `transfer_certificate()`

```rust
/// Transfiere la propiedad de un certificado NFT a otra direcci√≥n
/// 
/// Solo puede ser invocado por el propietario actual del certificado.
/// 
/// # Argumentos
/// * `env` - El entorno del contrato
/// * `certificate_id` - ID √∫nico del certificado (u32)
/// * `from` - Direcci√≥n del propietario actual
/// * `to` - Direcci√≥n del nuevo propietario
/// 
/// # Retorna
/// `()` - √âxito
/// 
/// # Errores
/// * `ContractError::NotFound` si el certificado no existe
/// * `ContractError::NotOwner` si 'from' no es el propietario actual
/// 
/// # Autorizaci√≥n
/// Requiere autenticaci√≥n de `from`
pub fn transfer_certificate(
    env: Env,
    certificate_id: u32,
    from: Address,
    to: Address,
) -> Result<(), ContractError> {
    // ‚úÖ AUTORIZACI√ìN CR√çTICA: Solo el propietario actual puede transferir
    from.require_auth();

    // Verificar que el certificado existe
    let cert_key = DataKey::Certificates(certificate_id);
    if env.storage().persistent().get::<DataKey, VerificationRecord>(&cert_key).is_none() {
        return Err(ContractError::NotFound);
    }

    // Obtener el propietario actual
    let owner_key = DataKey::CertificateOwner(certificate_id);
    let current_owner: Address = env.storage().persistent().get(&owner_key)
        .ok_or(ContractError::NotFound)?;

    // ‚úÖ VERIFICAR PROPIEDAD: 'from' debe ser el propietario actual
    if current_owner != from {
        return Err(ContractError::NotOwner);
    }

    // Transferir la propiedad
    env.storage().persistent().set(&owner_key, &to);

    // ‚úÖ EMITIR EVENTO: Notificar la transferencia del certificado
    CertificateTransferredEvent {
        certificate_id,
        from,
        to,
    }
    .publish(&env);

    Ok(())
}
```

**Flujo de Transferencia:**
1. **Autorizaci√≥n**: `from.require_auth()` - Solo el firmante puede transferir
2. **Verificaci√≥n de Existencia**: Certificado debe existir
3. **Verificaci√≥n de Propiedad**: `from` debe ser el propietario actual
4. **Actualizaci√≥n de Estado**: Cambiar propietario en Persistent Storage
5. **Emisi√≥n de Evento**: Notificar la transferencia
6. **Retorno**: `Ok(())`

### 6. Actualizaci√≥n de `mint_certificate()`

```rust
// ‚úÖ ESTABLECER PROPIETARIO INICIAL: El agricultor es el propietario inicial del NFT
let owner_key = DataKey::CertificateOwner(certificate_id);
env.storage().persistent().set(&owner_key, &record.farmer_address);
```

**Comportamiento:**
- Al acu√±ar un certificado, el `farmer_address` se convierte en el propietario inicial
- Se almacena en Persistent Storage para longevidad
- Proporciona base para futuras transferencias

---

## üß™ Tests Implementados

### Test 1: Propietario Inicial

```rust
#[test]
fn test_get_certificate_owner_initial() {
    let env = Env::default();
    env.mock_all_auths();
    
    let contract_id = env.register_contract(None, CarbonCertifier);
    let client = CarbonCertifierClient::new(&env, &contract_id);
    
    // ... setup ...
    
    client.mint_certificate(&1, &record);
    
    // El propietario inicial debe ser el agricultor
    let owner = client.get_certificate_owner(&1);
    assert_eq!(owner, farmer_address);
}
```

### Test 2: Certificado No Encontrado

```rust
#[test]
fn test_get_certificate_owner_not_found() {
    // Intentar obtener propietario de certificado inexistente
    let result = client.try_get_certificate_owner(&999);
    assert!(result.is_err());
}
```

### Test 3: Transferencia Exitosa

```rust
#[test]
fn test_transfer_certificate_success() {
    // Acu√±ar certificado
    client.mint_certificate(&1, &record);
    
    // Verificar propietario inicial
    assert_eq!(client.get_certificate_owner(&1), farmer_address);
    
    // Transferir certificado de farmer a new_owner
    client.transfer_certificate(&1, &farmer_address, &new_owner_address);
    
    // Verificar nuevo propietario
    assert_eq!(client.get_certificate_owner(&1), new_owner_address);
}
```

### Test 4: Transferencia Sin Autorizaci√≥n

```rust
#[test]
fn test_transfer_certificate_unauthorized() {
    // mock_all_auths() est√° activado, pero el test 
    // "test_transfer_certificate_not_owner" ya verifica la validaci√≥n
    
    // En producci√≥n, require_auth() rechazar√≠a autom√°ticamente
    // si el thief no firm√≥ la transacci√≥n
}
```

**Nota:** Este test es redundante en el entorno de testing porque `mock_all_auths()` simula que todos est√°n autenticados. En producci√≥n, `require_auth()` proporciona la seguridad.

### Test 5: Transferencia Sin Ser Propietario

```rust
#[test]
fn test_transfer_certificate_not_owner() {
    // Acu√±ar certificado (propietario es farmer_address)
    client.mint_certificate(&1, &record);
    
    // farmer_address intenta transferir pero especifica fake_owner como 'from'
    let result = client.try_transfer_certificate(&1, &fake_owner, &new_owner);
    
    // Debe fallar porque fake_owner no es el propietario real
    assert!(result.is_err());
}
```

### Test 6: Cadena de Transferencias

```rust
#[test]
fn test_transfer_certificate_chain() {
    // Acu√±ar certificado
    client.mint_certificate(&1, &record);
    
    // Cadena de transferencias: A -> B -> C
    client.transfer_certificate(&1, &address_a, &address_b);
    assert_eq!(client.get_certificate_owner(&1), address_b);
    
    client.transfer_certificate(&1, &address_b, &address_c);
    assert_eq!(client.get_certificate_owner(&1), address_c);
}
```

---

## ‚úÖ Resultados de Tests

```
running 32 tests
test test::test_get_certificate_owner_initial ... ok
test test::test_get_certificate_owner_not_found ... ok
test test::test_transfer_certificate_unauthorized ... ok
test test::test_transfer_certificate_not_owner ... ok
test test::test_transfer_certificate_success ... ok
test test::test_transfer_certificate_chain ... ok
// ... todos los tests anteriores ...

test result: ok. 32 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
```

**Cobertura:**
- ‚úÖ Propietario inicial correcto
- ‚úÖ Error para certificado inexistente
- ‚úÖ Transferencia exitosa
- ‚úÖ Prevenci√≥n de transferencia sin ser propietario
- ‚úÖ Cadena de transferencias
- ‚úÖ Autorizaci√≥n (garantizada por `require_auth()`)

---

## üîê Seguridad y Dise√±o

### Mecanismo de Doble Verificaci√≥n

**1. Autenticaci√≥n:**
```rust
from.require_auth();
```
- Solo el firmante de la transacci√≥n puede transferir
- Prevenci√≥n de transferencias no autorizadas
- Garant√≠a on-chain

**2. Verificaci√≥n de Propiedad:**
```rust
if current_owner != from {
    return Err(ContractError::NotOwner);
}
```
- Doble verificaci√≥n de la propiedad
- Prevenci√≥n de transferencias falsas
- Seguridad adicional

### Persistent Storage

**Ventajas:**
- Longevidad: Los datos persisten a trav√©s de ledger entries
- Eficiencia: Acceso directo por `certificate_id`
- Escalabilidad: No causa state bloat

### Eventos Inmutables

**Beneficios:**
- Auditor√≠a completa de transferencias
- Indexaci√≥n por explorers off-chain
- Notificaciones en tiempo real
- Trazabilidad completa

---

## üìä Modelo NFT

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   VerificationRecord (Inmutable)    ‚îÇ
‚îÇ   - verifier_address                ‚îÇ
‚îÇ   - farmer_address (original)       ‚îÇ
‚îÇ   - hectares_not_burned             ‚îÇ
‚îÇ   - co2e_tons                       ‚îÇ
‚îÇ   - metadata_hash                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                  ‚îÇ
                  ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   CertificateOwner (Mutable)        ‚îÇ
‚îÇ   certificate_id ‚Üí Address          ‚îÇ
‚îÇ   Actualizable por transfer_cert()  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                  ‚îÇ
                  ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   CertificateTransferredEvent       ‚îÇ
‚îÇ   - certificate_id                  ‚îÇ
‚îÇ   - from                            ‚îÇ
‚îÇ   - to                              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Caracter√≠sticas:**
- **Metadatos Inmutables**: Datos de verificaci√≥n no cambian
- **Propiedad Mutable**: Cambio de propietario con autorizaci√≥n
- **Eventos Auditables**: Registro completo de transferencias

---

## üíª Ejemplos de Uso

### Consultar Propietario

```typescript
// Obtener el propietario actual de un certificado
const owner = await contract.get_certificate_owner(certificateId);
console.log(`Propietario del certificado ${certificateId}: ${owner}`);
```

### Transferir Certificado

```typescript
// Transferir certificado a otra direcci√≥n
await contract.transfer_certificate(
    certificateId,
    fromAddress,  // Propietario actual (debe firmar)
    toAddress     // Nuevo propietario
);
```

### Escuchar Transferencias

```typescript
// Escuchar eventos de transferencia
const events = await stellarNetwork.getContractEvents({
    contractId: CONTRACT_ID,
    topics: [['CertificateTransferred']],
});

for (const event of events) {
    const data = event.data as CertificateTransferredEvent;
    console.log(`Certificado ${data.certificate_id} transferido:`);
    console.log(`  De: ${data.from}`);
    console.log(`  A: ${data.to}`);
}
```

### Dashboard de Propiedad

```typescript
interface CertificateOwnership {
    certificateId: number;
    owner: string;
    metadata: VerificationRecord;
    transferHistory: CertificateTransferredEvent[];
}

async function getCertificateOwnership(
    certificateId: number
): Promise<CertificateOwnership> {
    const owner = await contract.get_certificate_owner(certificateId);
    const metadata = await contract.get_certificate_data(certificateId);
    
    // Obtener historial de transferencias del explorer
    const transferHistory = await fetchTransferHistory(certificateId);
    
    return {
        certificateId,
        owner,
        metadata,
        transferHistory
    };
}
```

---

## üéì Conceptos Clave

### NFT (Non-Fungible Token)

Los certificados de carbono son NFTs porque:
1. **√önicos**: Cada certificado tiene un ID √∫nico y metadatos inmutables
2. **Rastreables**: Propiedad on-chain verificable
3. **Transferibles**: Cambio de propiedad con autorizaci√≥n
4. **Auditables**: Historial completo de transferencias

### Modelo de Propiedad

- **Farmer Address (Original)**: Beneficiario inicial del certificado
- **Current Owner (Mutable)**: Propietario actual (actualizable)
- **Transfer Chain**: Historial de propietarios por eventos

### Seguridad de Transferencia

**Mecanismos:**
1. **require_auth()**: Solo el firmante puede transferir
2. **Verificaci√≥n de Propiedad**: `from` debe ser el propietario actual
3. **Eventos Inmutables**: Registro completo de transferencias

---

## üöÄ Casos de Uso

### 1. Mercado de Cr√©ditos de Carbono

```typescript
// Un agricultor vende su certificado a una empresa
await contract.transfer_certificate(
    certificateId,
    farmerAddress,
    companyAddress
);

// La empresa puede retirar el cr√©dito o revenderlo
```

### 2. Crowdfunding de Compensaci√≥n

```typescript
// M√∫ltiples contribuyentes compran acciones de un certificado
// (requerir√≠a l√≥gica adicional de fraccionamiento)
```

### 3. Transferencia Hereditaria

```typescript
// Un agricultor transfiere su portafolio de certificados
for (const certId of certificateIds) {
    await contract.transfer_certificate(
        certId,
        originalOwner,
        heirAddress
    );
}
```

### 4. Auditor√≠a de Cadena de Custodia

```typescript
// Verificar la cadena completa de propiedad
async function verifyCustodyChain(certificateId: number) {
    const transfers = await fetchTransferHistory(certificateId);
    
    // Verificar que cada transferencia fue v√°lida
    for (const transfer of transfers) {
        // Validar cada transferencia en el hist√≥rico
    }
}
```

---

## üìà Beneficios de Implementaci√≥n

### 1. Intercambiabilidad
- ‚úÖ Certificados transferibles
- ‚úÖ Mercados secundarios posibles
- ‚úÖ Liquidez para agricultores

### 2. Transparencia
- ‚úÖ Propiedad verificable on-chain
- ‚úÖ Historial completo de transferencias
- ‚úÖ Auditor√≠a p√∫blica

### 3. Seguridad
- ‚úÖ Doble verificaci√≥n de autorizaci√≥n
- ‚úÖ Prevenci√≥n de robos
- ‚úÖ Trazabilidad completa

### 4. Flexibilidad
- ‚úÖ Transferencias peer-to-peer
- ‚úÖ Integraci√≥n con mercados
- ‚úÖ Casos de uso extensibles

---

## üéØ Pr√≥ximos Pasos Sugeridos

### Paso 9: Funciones de B√∫squeda Avanzada
- [ ] `list_certificates_by_owner()` - Listar certificados por propietario
- [ ] `get_owner_history()` - Obtener historial de propietarios
- [ ] `search_certificates()` - B√∫squeda por m√∫ltiples criterios

### Paso 10: Operadores Autorizados
- [ ] `approve_operator()` - Aprobar operador para transferir
- [ ] `transfer_from()` - Transferir en nombre de otro
- [ ] `revoke_approval()` - Revocar autorizaci√≥n

### Paso 11: Burning (Quemado)
- [ ] `burn_certificate()` - Quemar certificado (retiro permanente)
- [ ] Eliminar de √≠ndices
- [ ] Eventos de burning

---

## üìù Notas T√©cnicas

### Limitaciones Actuales

1. ‚ö†Ô∏è **Sin Aprobaciones**: No hay operadores autorizados (como ERC-721 `approve()`)
2. ‚ö†Ô∏è **Sin Burning**: No se pueden retirar certificados permanentemente
3. ‚ö†Ô∏è **Sin Metadata Din√°mica**: Metadatos del certificado son inmutables

### Consideraciones de Gas

Para una transferencia:
- Lecturas: 2 (verificar certificado, obtener propietario actual)
- Escrituras: 1 (actualizar propietario)
- Evento: 1
- Costo estimado: ~bajo

### Trade-offs

**Ventajas:**
- Implementaci√≥n simple
- Seguridad robusta
- Compatible con no_std

**Desventajas:**
- No hay operadores aprobados
- No hay burning
- Sin metadata din√°mica

---

## üîó Referencias

- [Paso 1: Contrato Base](./PASO_1_CONTRATO_BASE.md)
- [Paso 5: Validaci√≥n y Eventos](./PASO_5_VALIDACION_EVENTOS.md)
- [Paso 7: Ordenamiento y Filtrado](./PASO_7_ORDENAMIENTO_FILTRO.md)
- [Soroban Contract Events](https://developers.stellar.org/docs/build/smart-contracts)
- [ERC-721 Standard](https://eips.ethereum.org/EIPS/eip-721)

---

**Documento generado:** 29 de Octubre, 2025  
**Autor:** Auto (AI Assistant)  
**Versi√≥n del Contrato:** 0.0.8  
**Estado:** ‚úÖ Completo - NFT Functional

